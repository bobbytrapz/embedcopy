// A small tool that compresses data using gzip then
// generates a go package with a function for decompressing and reading the data.
// This allows us to embed assets into a binary.
// Possible use cases are embedding html/images for a web server or sprites in a game.
// ex: embedcopy -package assets -function IndexHTML <index.html >assets/index.go
package main

import (
	"bytes"
	"compress/gzip"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
)

var (
	packName = "main"
	funcName = "readEmbed"
	level    = "size"
)

func init() {
	flag.StringVar(&packName, "package", "main", "Name for package")
	flag.StringVar(&funcName, "function", "readEmbed", "Name for embedded data reader function")
	flag.StringVar(&level, "level", "size", "Compression level (none, default, speed, size)")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of embedcopy:\n")
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\n\nExample: embedcopy -package copy -function ReadCopy <main.go >copy.go\n")
	}
}

func die(msg string, err error) {
	log.Fatalf("%s: %s\n", msg, err)
}

type embedData struct {
	PackageName  string
	FunctionName string
	Data         []byte
}

const tmpl = `// Code generated by embedcopy. DO NOT EDIT.
package {{.PackageName}}
import (
  "compress/gzip"
  "bytes"
  "io"
)
// {{.FunctionName}} decompresses and returns embedded data
func {{.FunctionName}}() (io.Reader, error) {
  return gzip.NewReader(bytes.NewReader([]byte{{bytesString .Data}}))
}
`

var funcMap = template.FuncMap{
	"bytesString": bytesString,
}

func bytesString(data []byte) string {
	var sb strings.Builder
	fmt.Fprintf(&sb, "{")
	for ndx, b := range data {
		if ndx%12 == 0 {
			fmt.Fprintf(&sb, "\n")
		}
		fmt.Fprintf(&sb, "0x%02x,", b)
	}
	fmt.Fprintf(&sb, "}")
	return sb.String()
}

var embedTemplate = template.Must(template.New("").Funcs(funcMap).Parse(tmpl))

func main() {
	flag.Parse()

	var compressionLevel int
	switch level {
	case "none":
		compressionLevel = gzip.NoCompression
	case "default":
		compressionLevel = gzip.DefaultCompression
	case "size":
		compressionLevel = gzip.BestCompression
	case "speed":
		compressionLevel = gzip.BestSpeed
	default:
		fmt.Fprintf(os.Stderr, "level may equal none, default, size, or speed\n")
		os.Exit(1)
	}

	data := &bytes.Buffer{}
	io.Copy(data, os.Stdin)

	compressed, err := compress(data, compressionLevel)
	if err != nil {
		die("compress", err)
	}

	tmplBuf := &bytes.Buffer{}
	vars := embedData{
		PackageName:  packName,
		FunctionName: funcName,
		Data:         compressed.Bytes(),
	}
	if err := embedTemplate.Execute(tmplBuf, vars); err != nil {
		die("embedTemplate.Execute", err)
	}

	src, err := format.Source(tmplBuf.Bytes())
	if err != nil {
		die("format.Source", err)
	}

	io.Copy(os.Stdout, bytes.NewReader(src))
}

func compress(data *bytes.Buffer, level int) (*bytes.Buffer, error) {
	compressed := &bytes.Buffer{}
	zip, err := gzip.NewWriterLevel(compressed, level)
	if err != nil {
		die("gzip.NewWriterLevel", err)
	}
	if _, err := zip.Write(data.Bytes()); err != nil {
		die("zip.Write", err)
	}
	if err := zip.Close(); err != nil {
		die("zip.Close", err)
	}
	return compressed, nil
}
